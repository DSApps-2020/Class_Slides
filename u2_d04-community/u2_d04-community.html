<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Community Detection</title>
    <meta charset="utf-8" />
    <meta name="author" content="Giora Simchoni" />
    <meta name="date" content="2020-01-21" />
    <head>
      <link rel="icon" href="../DSApps_logo.jpg" type="image/jpg"> 
      <link rel="shortcut icon" href="../DSApps_logo.jpg" type="image/jpg">
    </head>
    <link rel="stylesheet" href="..\slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: logo-slide

---

class: title-slide

## Community Detection

### Applications of Data Science - Class 9

### Giora Simchoni

#### `gsimchoni@gmail.com and add #dsapps in subject`

### Stat. and OR Department, TAU
### 2020-01-21

---



layout: true

&lt;div class="my-footer"&gt;
  &lt;span&gt;
    &lt;a href="https://dsapps-2020.github.io/Class_Slides/" target="_blank"&gt;Applications of Data Science
    &lt;/a&gt;
  &lt;/span&gt;
&lt;/div&gt;

---

class: section-slide

# Intro

---

### Why detect communities?

- Understand hidden structure
- Identify separate functionalities
- Categorize (e.g. for automating Search &amp; Browse)
- Divide &amp; Conquer (e.g. for visualization)
- Optimize (e.g. with software)
- Reduce size of large networks
- Sheer Coolness

### What's a "good" community?

- Either "ground truth" .font80percent[(supervised)]
- Many edges within (dense), few edges between (sparse) .font80percent[(unsupervised)]

---

class: section-slide

# Spectral Partitioning

---

Start with dividing the network into 2 communities.

.insight[
ðŸ’¡ What is the number of ways to divide n nodes into two distinct groups?
]

The *cut size* between two sets of nodes is the number of edges between them:

`\(R=\frac{1}{2}\sum_{ij \text{ in different groups}}A_{ij}\)`

Define `\(\mathbf{s}\)` the vector which indicates to which community a network belongs:

`$$s_i =
 \begin{cases}
   +1 &amp; \mbox{if node}\ i \mbox{ belongs to community 1} \\
   -1 &amp; \mbox{if node}\ i \mbox{ belongs to community 2}
 \end{cases}$$`

Then:
 
`$$\frac{1}{2}(1-s_is_j) =
 \begin{cases}
   1 &amp; \mbox{if nodes}\ i,j \mbox{ belong to different communities} \\
   -1 &amp; \mbox{if nodes}\ i,j \mbox{ belong to the same community}
 \end{cases}$$`

---

So we can sum over all `\(i,j\)` to express `\(R\)`:

`\(R=\frac{1}{4}\sum_{ij}A_{ij}(1-s_is_j)=\frac{1}{4}\sum_{ij}(A_{ij}-A_{ij}s_is_j)\)`

Do you see where we're going with this?

`\(\sum_{ij}A_{ij}=\sum_i\sum_jA_{ij}=\sum_ik_i=\sum_ik_is_i^2=\sum_{ij}k_i\delta_{ij}s_is_j\)`

Where `\(\delta_{ij}\)` is the *Kronecker delta*, which is 1 if `\(i = j\)` and 0 otherwise.

Then the cut size can be written as:

`\(R=\frac{1}{4}\sum_{ij}(k_i\delta_{ij}-A_{ij})s_is_j=\frac{1}{4}\sum_{ij}L_{ij}s_is_j=\frac{1}{4}\mathbf{s}^\intercal\mathbf{L}\mathbf{s}\)`

Where `\(L\)` is the network Laplacian defined earlier.

And so we want to minimize `\(\frac{1}{4}\mathbf{s}^\intercal\mathbf{L}\mathbf{s}\)` s.t. `\(s_i=\pm1\)`.

---

Now suppose `\(n_1\)` and `\(n_2\)`, no. of nodes expected in community 1 and 2 are known .font80percent[(not unrealistic, especially with equal sizes and when you want to avoid degenrate scenarios)].

`\(\sum_is_i=\mathbf{1}^\intercal\cdot\mathbf{s}=n_1-n_2\)`

Relaxation:

We get rid of having `\(s_i=\pm1\)`, instead we'll require `\(\sum_is_i^2=\mathbf{s}^\intercal\mathbf{s}=n\)`

Applying Lagrange multipliers we get:

`\(\frac{\partial R}{\partial s}=\frac{\partial}{\partial s}\frac{1}{4}\mathbf{s}^\intercal\mathbf{L}\mathbf{s}+\lambda(n-\mathbf{s}^\intercal\mathbf{s})+2\mu((n_1-n_2)-\mathbf{1}^\intercal\cdot\mathbf{s})\)`

Equating to 0 to find the minimum and performing the derivatives we get:

`\(\mathbf{Ls}=\lambda\mathbf{s}+\mu\mathbf{1}\)`

---

.font80percent[(Here if we have time I can show you how we get to...)]

Finally, the solution for `\(\mathbf{s}\)` is:

`\(\mathbf{s}=\mathbf{v_2}+\frac{n1-n2}{n}\)`

Where `\(\mathbf{v_2}\)` is the Fiedler vector: eigenvector of `\(L\)`, which corresponds to `\(\lambda\)`, the second smallest (after zero) eigenvalue of `\(L\)`.

But `\(\mathbf{s}\)` needs to be at `\(\pm1\)`, so bottom line we take the `\(n_1\)` most positive values in `\(\mathbf{v_2}\)` and put the relevant nodes in community 1, and the rest of the `\(n_2\)` nodes in community 2.

It can be shown that `\(R=\frac{n_1n_2}{n}\lambda\)`, hence `\(\lambda\)`, the second smallest eigenvalue of `\(L\)` (a.k.a *algebraic connectivity*) determines the cut size, how easy it is to divide the network into two communities of sizes `\(n_1\)` and `\(n_2\)`

.insight[
ðŸ’¡ What if `\(\lambda=0\)`?
]

---

Regarding implementation, I do not think Spectral Clustering is implemented in NetworkX, however you can either implement it yourself or use [`SpectralClustering()`](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html) from Scikit-Learn.

.font80percent[
The `SpectralClustering()` of Scikit-Learn isn't identical to what we defined though. I believe that after obtaining `\(\mathbf{v_2}\)`, there is no way of specifying `\(n_1\)` and `\(n_2\)`, instead all nodes with positive values in `\(\mathbf{v_2}\)` are taken for community 1 and all nodes with negative values are taken to community 2.
]


```python
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from sklearn.cluster import SpectralClustering

scifi_edgelist = pd.read_csv('../data/sci_fi_final_edgelist.csv')
G = nx.from_pandas_edgelist(scifi_edgelist, 'book', 'book2', ['corr'])
A = nx.to_numpy_matrix(G)
sc = SpectralClustering(2, affinity='precomputed', n_init=100,
  assign_labels='discretize')
communities = sc.fit_predict(A)

communities[:10]
```

```
## array([1, 1, 1, 1, 1, 0, 0, 1, 1, 0], dtype=int64)
```

---


```python
color_dict = {0: 'blue', 1: 'red'}
nx.draw_networkx(G, node_list = G.nodes,
  node_color = [color_dict[comm] for comm in communities])
plt.show()
```

&lt;img src="images/SpectralClustering-1.png" width="50%" /&gt;

---

class: section-slide

# Girvan-Newman (Betweennees)

---

[Girvan &amp; Newman (2002)](https://www.pnas.org/content/pnas/99/12/7821.full.pdf) suggested a divisive strategy of repeatedly removing "strongest" edges from the network, slowly uncovering the community structure of the network, until we're left with `\(n\)` communities for `\(n\)` nodes.

This will create a dendrogram of nodes, from a point where all are connected to where all are "leaves":

&lt;img src = "images/dendrogram.png" style = "width: 40%"&gt;

To choose the community structure best for you either cut the dendrogram where you get `\(k\)` communities or use some other metric.

But what criterion to choose for "strongest" edges?

---

Girvan &amp; Newman suggested *edge betweenness* which is the same *betweenness centrality* we have defined, using edges:

`\(x_e = \sum_{u,v}\frac{\tau(u,v|e)}{\tau(u,v)}\)`

Where `\(\tau(u,v)\)` is the number of shortest paths from node `\(u\)` to node `\(v\)` and `\(\tau(u,v|e)\)` is the number of those shortest paths which pass through edge `\(e\)`.

To summarize:

1. Calculate the betweenness for all edges in the network.
2. Remove the edge with the highest betweenness.
3. Recalculate betweennesses for all edges affected by the removal.
4. Repeat from step 2 until no edges remain.

.insight[
ðŸ’¡ Why recalculate betweenness at each iteration?
]

---


```python
communities = nx.community.girvan_newman(G) # returns an iterator on tuples of sets of nodes
community1, community2 = tuple(next(communities)) # we take the first tuple for 2 communities

node_colors = []
for book in G.nodes:
  if book in community1:
    node_colors.append('blue')
  else:
    node_colors.append('red')
nx.draw_networkx(G, node_list = G.nodes, node_color = node_colors)
plt.show()
```

&lt;img src="images/Girvan-Newman-1.png" width="50%" /&gt;

---

Getting the actual dendrogram turned out to be quite laborious, you can see [here](https://stackoverflow.com/questions/59821151/plot-the-dendrogram-of-communities-found-by-networkx-girvan-newman-algorithm/59827653#59827653) how I got it to work or see the slides source (this chunk is hidden because it's a lot of code...)

&lt;img src="images/scifi-dendrogram-1.png" width="70%" /&gt;
---

class: section-slide

# Label Propagation

---

### Proposition 1: Synchronous

1. Initialize a unique label (community) for each node
2. For each node (in parallel): choose the the most common label in neighbors
3. If there is a tie: choose label at random
4. Go back to 2 until some stopping criteria (e.g. no change)

.font80percent[
Notice the beautiful idea of information diffusion, very democratic
]

Pros                          | Cons
----------------------------- | -----------------------
Relatively fast (in parallel) | May not converge
                              | Reproducibility issue
                              
.insight[
ðŸ’¡ Can you think of a network that will never converge?
]

---

### Proposition 2: Asynchronous

1. Initialize a unique label (community) for each node
2. Decide on a nodes permutation
3. For each node (one after the other): choose the the most common label in neighbors
4. If there is a tie: choose label at random
5. Go back to 2 until some stopping criteria (e.g. no change)


Pros               | Cons
------------------ | -----------------------
Relatively slow    | Even worse reproducibility issue, no single solution
Better convergence | "Monster communities"

---

### Improving Convergence

- Smarter tie breakers:
  - If the node is labelled with one of the tied labels in its neighborhood - keep it
  - Set an order on labels (e.g. `\(1, ..., l\)`) and always choose the max label
  - Or both

- Stopping Criterion
  - Unfortunately "no change in labels" may be too an optimistic criterion to achieve.
  - "Equilibrium": if in the current structure each node has a label no different than the majority label in its neighborhood - stop. In other words: if in the next iteration nodes will change label only due to ties - stop.

---

class: section-slide

# Detour: The Network Coloring Problem

---

Can you color a network using as few colors as possible, where no two adjacent nodes share the same nodes?


```python
F = nx.petersen_graph()
color_dict = nx.coloring.greedy_color(F)
colors = ['green', 'red', 'blue']
node_colors = [colors[color_ind] for node, color_ind in color_dict.items()]
nx.draw_shell(F, node_list=F.nodes, node_color=node_colors)
plt.show()
```

&lt;img src="images/Coloring-Problem-1.png" width="30%" /&gt;

.insight[
ðŸ’¡ Think of a not-so-fast simple algorithm to get this done (A fast algorithm can make this in O(max(deg(G))) time!)
]

---

The smallest number of colors required to color a given network `\(G\)` is called its *chromatic number*, `\(\chi(G)\)`

.insight[
ðŸ’¡ What is an "easy" upper bound on `\(\chi(G)\)`?
]

What is it good for?

- Scheduling: imagine each node is a university course and two courses share an edge if they have common students. How would you schedule exam times, such that no student has to attend two exams at the same time?
- Political map coloring: no two adjacent countries share a color
- A network `\(G\)` is bipartite iff `\(\chi(G)=2\)`
- Sudoku: 9x9=81 cells (nodes), two cells are connected if they are in the same row/column/square. Can you put in each cell 1 out of 9 numbers (colors) such that no two adjacent cells share the same number?
- And...

---

class: section-slide

# End of Detour

---

### Proposition 3: Both ("Semi-Synchronous")

1. Initialize a unique label (community) for each node
2.  Network coloring: assign a "color" to the nodes of the network such that no two adjacent nodes share the same color
3. **In each color group** (one after the other), for each node (in parallel): choose the the most common label in neighbors
4. If there is a tie: choose a label by one of the "smarter" tie breakers
5. Go back to 3 until some stopping criteria ("Equilibrium")

.insight[
ðŸ’¡ Do you see the sense in iterating the nodes in parallel *in each color group*?
]
---


```python
communities = nx.community.label_propagation_communities(G)

colors = ['green', 'blue', 'red', 'purple'] # cheating...
node_colors = []
books = []
color_ind = 0
for comm in communities:
  node_colors.extend([colors[color_ind]] * len(comm))
  color_ind += 1
  books.extend(list(comm))

colors_dict = {book: color for book, color in zip(books, node_colors)}
book_index = {book: i for i, book in enumerate(G.nodes)}
sorted_colors_dict = sorted(colors_dict.items(), key=lambda pair: book_index[pair[0]])
node_colors = [color for book, color in sorted_colors_dict]

plt.figure()
nx.draw_networkx(G, node_list = G.nodes, node_color = node_colors)
plt.show()
```

---

&lt;img src="images/unnamed-chunk-3-1.png" width="70%" /&gt;


---

class: section-slide

# Modularity Maximization

---

class: section-slide

# node2vec

---

class: section-slide

# Other methods

---

.pull-left[
Adjacency matrix based:
- Hierarchical Clustering
- K-Means
- Whatever you find in Scikit-Learn...

Heuristics:
- Kernighan-Lin

Modularity Maximization:
- Simulated Annealing
- Genetic Algorithms
]

.pull-right[
Nonnegative Matrix Factorization:
- BigCLAM

Deep Learning:
- Graph Neural Networks
- Graph Embeddings

Game Theory:
- GLEAM
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="../libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
